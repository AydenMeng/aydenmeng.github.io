---
title: 计算机二级Python
date: 2019-07-16 20:59:58
categories: [软件编程, Python]
tags: [Python, 计算机二极]
---

## 概述

计算机二级在近两年新加了python的选择，趁机考了一下，顺便记录一下学习的一些所获

<!--more-->

## 第一章 程序设计语言概述

### 考纲考点：

![1](/images/计算机二级Python/1.png)

这一部分主要是介绍计算机语言的公共常识，一些尝试我就按照自己的理解方式来记忆：

程序设计语言——计算机与人类之间的翻译官，所以称为交互体系，翻译官用的语言称为计算机程序，就像人类的语言有语法等等规则一样。

高级编程语言包括静态语言和脚本语言，python是解释语言，就是直接跟计算机对话的那种，也就是脚本语言；Java那种是需要编译才能执行的语言，就相当于需要二次翻译，是静态语言，因为静态（懒），还需要一个传话的才行。

官方用语的话，编译是将源代码转换成目标代码的过程，解释是将源代码逐条转换成目标代码的同时逐条运行目标代码的过程。二者区别可见下图来理解：

![2](/images/计算机二级Python/2.png)

![3](/images/计算机二级Python/3.png)

编译是一次性翻译，再传话，经过传话人以后，就不需要翻译官再翻译一遍了，所以一旦程序被编译，就不需要再次编译，所以重复执行速度更快，当然这个目标代码也就不再需要编译器。

解释是每次都需要解释，因为翻译一遍的外语容易忘，告诉传话人以后，传话人就不容易忘自己母语记忆的内容，但是解释是翻译官兼职传话人，所以只要翻译官存在，程序就可以执行。无论是那种系统，而且一个人干，程序纠错和维护也非常方便。

### Python语言概述

![](/images/计算机二级Python/4.png)

这是python的最小程序了。

至于python的开发环境配置这里就不介绍了，环境变量可以直接添加，比jdk方便多了

python的解释器有两个重要工具：IDLE——python集成开发环境（相当于人类、翻译官、计算机组成的整体），pip——python第三方库安装工具（邀请翻译官的功能）

Python程序的运行方式——交互式（命令行）、文件式（非命令行）

![](/images/计算机二级Python/5.png)

### 程序的基本编写方法

IPO程序编写方法——Input（输入，相当于人类编写代码这个过程），process（处理，相当于翻译），output（计算机得到翻译官给的信息做出响应）

### Python程序的特点

 Python具有通用性，因为应用领域广，所以才要学习，当作工具用也好

Python语法简洁，只有33个保留字，看起来就像英语正常表达一样

Python生态高产，库特别多，也就是翻译官特别充足，很多荒诞无理的要求都可以被翻译官听懂

除了Python语法的三个重要特点外，Python程序还 有一些具体特点。 

•平台无关：前面说到过，只要有翻译官就可以，在任何系统都可以运行

 •强制可读 ：也就是利用缩进来表明逻辑关系，相当于句子之间没有停顿，使用缩进来强制理解

•支持中文：看下图

![](/images/计算机二级Python/7.png)

## 第二章 Python语言基本语法元素

### 考纲考点：

![](/images/计算机二级Python/8.png)

### 程序的格式框架

#### 缩进：

Python语言采用严格的“缩进”来表明程序的 格式框架，用来表示代码之间的包含和层次关系。 1个缩进 = 4个空格 =1个退格。但是空格和退格不能混用。而且缩进是Python语言中表明程序框架的唯一手段。其重要性可见一斑。

![](/images/计算机二级Python/9.png)

#### 注释：

注释就是在输入的时候加入一些不想让翻译官翻译的东西，但是翻译官如何去区分哪些是要的，哪些是不要的呢？所以就有了注释，单行注释用井号。多行注释用三对引号，三队引号之间的内容就是被注释掉了。单引号双引号无所谓。

```
'''
这里面
都是注释
'''
#print("Hello!") 这是一条单行注释
"""
这里面
也都是注释
"""
```

#### 变量：

变量就是一个一个的小房子，用来存放东西的，经常用**一个等号**把东西放进变量（房子）里，也就是赋值。

```
a=3		#把3放进了a中
a==2	#两个等号是用来比较二者是否相同
```

#### 命名：

 Python语言允许采用大写字母、小写字母、数 字、下划线(_)和汉字等字符及其组合给变量命 名，但名字的首字符不能是数字，中间不能出现空格，长度没有限制 n。*注意：标识符对大小写敏感，python和Python 是两个不同的名字* 

#### 保留字：

python中你盖的房子是变量，早就存在的名胜建筑就是叫做保留字了，自己的房子爱咋咋地，名胜古迹可不能乱动，而且还不能建一个和名胜建筑一样的房子，要不然就侵权了，要坐牢（出bug）的！

![](/images/计算机二级Python/10.png)

### 数据类型

Python语言支持多种数据类型，最简单的包括**数字**类型、**字符串**类型，略微复杂的包括元组类型、集合类型、列表类型、字典类型等。

#### 数字类型

表示数字或数值的数据类型称为数字类型，Python语言提供3种数字类型：整数、浮点数和复数，分别对应数学中的整数、实数和复数。

一个整数值又可以表示为十进制、十六进制、八进制和二进制等不同进制形式。一个浮点数可以表示为带有小数点的一般形式，也可以采用科学计数法表示。

```
举个例子，看不懂也没关系
#整数类型
十进制： 1010 
十六进制：0x3F2 
八进制： 0o1762 
二进制： 0b001111110010
#浮点数类型
一般形式： 123.456 
科学计数法： 1.23456e2 
```

#### 字符串

至于字符串， Python语言中，字符串是用两个双引号“ ”或者单 引号‘ ’括起来的一个或多个字符。 

![](/images/计算机二级Python/11.png)

```
"hello world"[1]
输出：e
"hello world"[6]
输出：w
"hello world"[-1]
输出：d
```

可以采用[N: M]（左闭右开区间）格式获取字符串的子串，这个操作被形象地称为切片。

```
"hello world"[1：4]
输出：ell
"hello world"[6：-2]
输出：wor
```

可以通过Python默认提供的len()函数获取字符串 的长度，一个中文字符和西文字符的长度都记为1。 

```
len("hello")
输出：5
len("hello world")
输出：11
```

### 程序的语句元素

#### 表达式

产生或计算新数据值的代码片段称为表达式，简单说就是连接在一起的一个句子/短句

#### 赋值

前面提到过了，**一个等号**是赋值，而且是从右往左赋值，如`a=3`

#### 引用

 Python程序会经常使用当前程序之外已有的功能 代码，这个过程叫“引用”。Python语言使用 import保留字引用当前程序以外的功能库，使用方 式如下： `import <功能库名称>`

其实说白了就是请翻译官

#### 分支语句

 分支语句是控制程序运行的一种语句，它的作用是根据判断 条件选择程序执行路径。分支语句包括：单分支、二分支和 多分支。如：

```
a=3			#一开始告诉你a里面放的是3
if a==3:	#注意冒号，然后翻译一下，如果a等于3
	print("a=3没毛病")		#注意缩进，表示上一句的"断句",翻译为"则输出a=3没毛病"
```

#### 循环语句

循环语句是控制程序运行的一类重要语句，与分支 语句控制程序执行类似，它的作用是根据判断条件 确定一段程序是否再次执行一次或者多次。

```
#输出1到10中所有的自然数
n=1
while n<10:		#注意冒号，翻译——当n小于10的时候
	print(n)	#注意缩进，翻译——则输出n

```

### 基本输入输出函数

直接演示了

```
a=input("默认会输入字符串噢")	#输入函数input()，就算是输入数字也会当成字符串
b=eval("1.3+a")				   #输入函数eval(),里面就算是有字符串类型的数字，也会变成数字噢
print(a)					  #输出一串数字
print(b)					  #加入a输入了1，这里就输出2.3
print(1.3+a)					  #这里会报错噢，因为字符串类型的数字和数字不能相加
```

`print`函数还有个重要的地方：`print`函数输出讲道理是直接就换行了，因为`print()`里面自带换行，举个例子：

```
print(3,end="")		#不换行
print(3)			#换行，其实是print(3,end="\n"),后面的部分默认就不显示出来了
print(3,end="k")	#输出3k
```

## 第三章 基本数据类型

### 考纲考点

![](/images/计算机二级Python/12.png)

### 数字类型

前面提到过，python提供的数字类型有三种，整数、浮点、复数，翻译一下就算整数、实数、复数。

整数嘛，在前面加`0b`或者`0B`，就意味着你在写二进制数字，b代表`binary`，其他英文可自行查阅。

![](/images/计算机二级Python/13.png)

浮点和整数的区别就算10.10是浮点，10.0也是浮点，都不是整数。浮点数还可以用科学计数法来写，如`1010.0`, `-1010.`, `1.01e3`, `-1.01E-3`

至于复数，计算机可不像人变通那么多，`10+0j`是复数，`10`就不是复数，所以只要带`j`的数就算复数。

```
(1.23e4+5.67e4j).real  			#.real是用来获取实部，点翻译成“的”，real翻译为实部
12300.0 
(1.23e4+5.67e4j).imag 			#同上
56700.0 
1.23e4+5.67e4j.imag   			# 先获得5.67e4j的虚部，再与1.23e4进行求和计算 
69000.0
```

#### 数字类型的运算

|         操作符          |                             功能                             |
| :---------------------: | :----------------------------------------------------------: |
|           x+y           |                             求和                             |
|           x-y           |                             求差                             |
|           x*y           |                             求积                             |
|           x/y           |                             求商                             |
|          x//y           |          x与y之整数商，即：不大于x与y之商的最大整数          |
|          x**y           |                       x的y次幂，即：xy                       |
|           +x            |                              x                               |
|           -x            |                              -x                              |
|          x % y          |                 x与y之商的余数，也称为模运算                 |
|          x+=y           |                            x=x+y                             |
|          x*=y           |                            x=x*y                             |
|        依次类推         |                              ……                              |
|       **abs(x)**        |                        **x的绝对值**                         |
|    **divmod(x, y)**     |     **(x//y, x%y)，输出为二元组形式（也称为元组类型）**      |
|   **pow(x, y[, z])**    | **(xy)%z，[..]表示该参数可以省略，即：pow(x,y)，它与xy相同** |
| **round(x[, ndigits])** | **对x四舍五入，保留ndigits位小数。round(x)返回四舍五入的整数值** |
| **max(x1, x2, …, xn)**  |             **x1, x2, …, xn的最大值，n没有限定**             |
| **min(x1, x2, …, xn)**  |             **x1, x2, …, xn的最小值，n没有限定**             |

浮点数与整数运算，产生结果是浮点数 ，另外`int(10.10)`得到整数10，`int("10")`也会得到10，但是int("10.10")就会报错，打个比方就是你把10.10放进`int`的房子里时，int首先接待第一个字符，也就是1，他知道这是数字，就收下了，但是只能收下整数，当第一个字符是`"`时，他知道是字符串，就收下了，当然只要是整数就没问题，结果字符串给他一个浮点，他int就被撑炸了。

### 字符串类型及格式化

```
print('这是"单行字符串"') 
这是"单行字符串" 
print("这是'单行字符串'") 
这是'单行字符串' 
print("""这是'多行字符串'的第一行 这是'多行字符串'的第二行 """) 
这是'多行字符串'的第一行 这是'多行字符串'的第二行 
print('''这是"多行字符串"的第一行 这是"多行字符串"的第二行 ''') 
这是"多行字符串"的第一行 这是"多行字符串"的第二行
```

**重点**，这个好像在考试经常会挖坑：Python语言转义符： \ ，例如：\n表示换行、\\表示反斜杠、\'表示单引 号、\"表示双引号、\t表示制表符（TAB）等。

然后这个叫字符串的索引，切片，字面意思

```
"hello world"[1]
输出：e
"hello world"[6]
输出：w
"hello world"[-1]
输出：d
```

**重点**，format()方法的基本使用，举几个例子，自己理解比书面用于可能会好理解一点

```
"{}曰：学而时习之，不亦说乎。".format("孔子") 
'孔子曰：学而时习之，不亦说乎。'
"{}曰：学而时习之，不亦{}。".format("孔子","说乎") 
'孔子曰：学而时习之，不亦说乎。'
"{1}曰：学而时习之，不亦{0}。".format("说乎","孔子") 
'孔子曰：学而时习之，不亦说乎。' 
"{1}曰：{{学而时习之，不亦{0}}}。".format("说乎","孔子")
'孔子曰：{学而时习之，不亦说乎}。'
```

然后我总结一下：**大括号就相当于座位，format里面就是即将入座的学生，大括号里没数字的就代表座位没写名字，谁排前面谁坐，有数字就按数字坐，当然最前的数字是第0，当然如果大括号里本来就有东西，那些代表刻在桌子上的其他字，照例输出就行**

除此之外，format还有控制格式的作用：

```
s = "等级考试"				#在下面的25代表输出的字符数量
"{:25}".format(s)           #左对齐，默认 '等级考试		   		'
"{:^25}".format(s)          #居中对齐 '          等级考试           '
"{:>25}".format(s)          #右对齐 '                     等级考试'
"{:*^25}".format(s)         #居中对齐且填充*号 '**********等级考试***********'
"{:+^25}".format(s)         #居中对齐且填充+号 '++++++++++等级考试+++++++++++'
"{:十^25}".format(s)        #居中对齐且填充汉字“十” '十十十十十十十十十十等级考试十十十十十十十十十十十' 
"{:^1}".format(s)           #指定宽度为1，不足变量s的宽度 '等级考试'
"{:.2f}".format(12345.67890) 						#'12345.68' 
"{:>25.3f}".format(12345.67890)  					 # '                12345.679'
"{:.5}".format("全国计算机等级考试")	#'全国计算机'
"{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}".format(425)		# '110101001,Ʃ,425,651,1a9,1A9'			b: 输出整数的二进制方式； c: 输出整数对应的Unicode字符； d: 输出整数的十进制方式； o: 输出整数的八进制方式； x: 输出整数的小写十六进制方式； X: 输出整数的大写十六进制方式； 
"{0:e},{0:E},{0:f},{0:%}".format(3.14) 			#'3.140000e+00,3.140000E+00,3.140000,314.000000%' 
"{0:.2e},{0:.2E},{0:.2f},{0:.2%}".format(3.14) 	 #对比输出 '3.14e+00,3.14E+00,3.14,314.00%'
```

这个读者自行总结好了吧，适合自己的记忆才是有用的，官方解释以后遇到再说，反正能看懂

其实常用的就几个

```
"{:.2f}".format(3.1415926)  		 # 输出小数点后两位 '3.14' 
"{:x}".format(1010)          		 # 输出整数的十六机制形式 '3f2' 
"{:.5}".format("这是一个很长的字符串")  # 输出字符串的前5位 '这是一个很'
"{:-^10}".format("PYTHON")   		  # 居中并填充 '--PYTHON--'
```

#### 字符串类型的操做

|     操作符     |                            翻译                             |
| :------------: | :---------------------------------------------------------: |
|     x + y      |                     连接两个字符串x与y                      |
| x * n 或 n * x |                       复制n次字符串x                        |
|     x in s     | 如果x是s的子串，返回True，否则返回False，'Y' in name →False |

字符串处理函数

|  函数  |                         描述                          |
| :----: | :---------------------------------------------------: |
| len(x) | 返回字符串x的长度，也可返回其他组合数据类型的元素个数 |
| str(x) |            返回任意类型x所对应的字符串形式            |
| chr(x) |             返回Unicode编码x对应的单字符              |
| ord(x) |             返回单字符x表示的Unicode编码              |
| hex(x) |        返回整数x对应十六进制数的小写形式字符串        |
| oct(x) |                        oct(x)                         |

放张图自行参悟![](/images/计算机二级Python/15.png)

在学习类型这一块，`type()`函数是个好东西，他能帮你得到你想要知道的东西的类型。比如`print(type(123))`就会打印出int，其他的也都可以用。

## 第四章 程序的控制结构

### 考纲考点

![](/images/计算机二级Python/16.png)

### 程序的基本结构

**任何**程序**最多**由**三种**基本结构组成：顺序结构、分支结 构和循环结构。 一条一条向下进行的翻译就是顺序结构，向下翻译时遇到需要跳过的部分就是分支(`if\swich`语句)，翻译到下面某处又返回到上面的就是循环(`while\for`语句)、

在这种逻辑语句中，缩进要特别注意，与程序逻辑相关很大，冒号也要重视，这是格式要求

#### 分支结构

```
# 判断用户输入数字的特点
s = eval(input("请输出一个整数：")) 				#假如输入7
if s % 3 == 0 and s % 5 == 0:					  #这句话就要跳过，因为7不满足这个条件，所以就是分支
	print("这个数字既能被3整除，又能被5整除") 
else:											#如果输入15，这句话就要跳过
	print("输入数字是:", s)
```

有时候需要很多条岔路口，那就是else 后面再加一句 if，但是这种写法有规定，拼写成`elif`，然后有几个if就算几分支语句

| 操作符 |   含义   |
| :----: | :------: |
|   <    |   小于   |
|   >    |   大于   |
|   <=   | 小于等于 |
|   >=   | 大于等于 |
|   ==   |   等于   |
|   !=   |  不等于  |

#### 循环结构

```
for c in "Python":				#这种也成为for的循环遍历
	print(c)
#输出结果如下：
P 
y 
t 
h 
o
n
#同样的效果还有：
for i in range(6):				#for循环经常搭配range函数使用
	print("Python"[i])
i = 0							#while的用法
while i < 6:
	print("Python"[i])
```

##### 循环控制

循环的时候如果遇到在一范围内不想继续运行的情况，就需要用到循环控制了——`break`和`continue`，`break`跳出整个循环，`continue`跳出当此循环

以for循环为例：

```
for i in range(6):
	if i == 1:
		continue
	elif i ==3:
		break
	print("Python"[i])
#输出结果如下：
P #从第0号开始
#y 第1号不输出
t 
#以下都不输出，因为到了第三号
h 
o
n
```

### 程序的异常处理

Python语言使用保留字try和except进行异常处理，try后面如果遇到错误了，就执行except后面的，有点像if分支语句的感觉，举个例子

```
try:
	for i in range(5):
		print(10/i, end=" ") 
except:     
	print("某种原因，出错了！") 
```

上面例子中，当`i`循环时，会从0开始，这样就出现除数为0的情况，这样讲道理是要报错的，但是遇到错误会执行except后面的代码，所以最后知识输出一句“某种原因，出错了！”酱紫。

## 第五章 函数和代码复用

### 考点考纲

![](/images/计算机二级Python/17.png)

### 函数的基本使用

首先是定义函数，如下就定义完了，要注意的只有缩进和冒号

```
def 函数(一些函数需要用到的参数):
	一些代码
	return 一些返回值，当然也可以没有
```

定义了就要用，如下

```
def multiply(x, y):			#定义函数
	print(x*y) 
multiply(99, 2) 			#调用函数，输出198

def multiply(x=10, y):		#定义函数
	print(x*y) 
multiply(2) 				#调用函数，输出20

def multiply(x, y=10):		#定义函数
	print(x*y) 
multiply(99) 				#调用函数，输出990
multiply(y = 2, x = 99) 	#调用函数，输出198
```

### 变量的作用域

在谁的冒号下面的缩进下就是作用于谁的变量，除了那个冒号和缩进的范围就没用了。

```
def hanshu():
	n=3
	print(n)		#不报错
print(n)			#报错

n=2
def hanshu():
	print(n)		#报错
print(n)			#不报错
```

如果想要访问局部变量，科研在前面加上`global`用来强调是全局变量

```
n=2
def hanshu():
    n=3
    print(n)
def han():
    global n
    n=3
    print(n)
print(n)
hanshu()
han()
print(n)
#输出：
2
3
3
3
```

## 组合数据类型

### 考纲考点

![](/images/计算机二级Python/18.png)

### 组合数据类型的基本概念

#### 集合

集合是无序组合，用大括号（{}）表示，它没有 索引和位置的概念，集合中元素可以动态增加或删除。集合中元素不可重复，元素类型只能是固定数据类型，也就是说只能放你想赋值的东西，赋值过的房子是不能放进集合这种房子的。

```
S = {1010, "1010", 78.9}
type(S) 
<class 'set'> 		#输出
len(S)
3					#输出
print(S)
{78.9, 1010, '1010'}	#输出
```

集合类型有4个操作符，交集（&）、并集（|）、差集 （-）、补集（^），操作逻辑与数学定义相同。比如`S-T`得到一个新集合包括在集合S中但不在集合T中的元素 。

| 函数或方法  |                       描述                        |
| :---------: | :-----------------------------------------------: |
|  S.add(x)   |        如果数据项x不在集合S中，将x增加到s         |
| S.remove(x) | 如果x在集合S中，移除该元素；不在产生 KeyError异常 |
|  S.clear()  |                 移除S中所有数据项                 |
|   len(S)    |                 返回集合S元素个数                 |
|   x in S    |      如果x是S的元素，返回True，否则返回False      |
| x not in S  |     如果x不是S的元素，返回True，否则返回False     |

集合类型主要用于元素去重，适合于任何组合数据类型。

```
T = {1010, "1010", 12.3, 1010, 1010}
print(T) 
{1010, '1010', 12.3}
```

#### 序列

理解以下字符串就行，字符串就是一种字符序列

#### 列表

列表也是一种序列，参考一下字符串，这里写一下不同的地方

|      方法       |                描述                 |
| :-------------: | :---------------------------------: |
|  ls.append(x)   |      在列表ls最后增加一个元素x      |
| ls.insert(i, x) |      在列表ls第i位置增加元素x       |
|   ls.clear()    |          删除ls中所有元素           |
|    ls.pop(i)    | 将列表ls中第i项元素取出并删除该元素 |
|  ls.remove(x)   |    将列表中出现的第一个元素x删除    |
|  ls.reverse()   |          列表ls中元素反转           |
|    ls.copy()    |  生成一个新列表，复制ls中所有元素   |

#### 字典

其实字典也是序列，但是字符串和列表都是把索引默认按`[0,len(list)-1]`来确定顺序，而字典的区别就是自己把确定顺序的东西写出来

```
d = {"201801":"小明", "201802":"小红", "201803":"小白"}
print(d["201802"]) 
小红

d = {"201801":"小明", "201802":"小红", "201803":"小白"}
len(d) 
3

#dict()函数用于生成一个空字典，作用和{}一致。 
d = dict()
print(d)
{}
```

稍微了解一点：排序的东西叫做keys，被排序的东西叫做values

|      操作方法       |                          描述                          |
| :-----------------: | :----------------------------------------------------: |
|      d.keys()       |                    返回所有的键信息                    |
|     d.values()      |                    返回所有的值信息                    |
|      d.items()      |                    返回所有的键值对                    |
| d.get(key, default) |           键存在则返回相应值，否则返回默认值           |
| d.pop(key, default) |   键存在则返回相应值，同时删除键值对，否则返回默认值   |
|     d.popitem()     | 随机从字典中取出一个键值对，以元组(key, value)形式返回 |
|      d.clear()      |                    删除所有的键值对                    |

## 第七章 文件和数据格式化

### 考纲考点

![](/images/计算机二级Python/6.png)

### 文件的使用

首先，读文件，分三个步骤，打开文件——读取文件——关闭文件

```
file1 = open('/Users/Ted/Desktop/test/abc.txt','r',encoding='utf-8') 
#第一个参数是文件路径，这里知识举个例子，第二个参数是表示打开时文件的状态，第三个参数是编码方式
```

路径有绝对路径和相对路径，相对当前文件夹的路径叫做相对路径，相对于我的电脑的路径是绝对路径。

文件打开时的状态是由“读read”“写write”“追加append”，以及与字节组合作用的效果，下图表示的是以二进制文件打开，把b换成t就算以文本文件方式打开，除了r、w、a还有x，表示如果文件不存在，则自行创建，如果存在就报错，而w是覆盖原文件的写，存在就覆盖，不存在就新建。

![](/images/计算机二级Python/19.png)

```
f = open(“a.txt”,“rb”) 		#b表示二进制文件方式 
print(f.readline()) 
f.close()
b'\xc8\xab\xb9\xfa\xbc\xc6\xcb\xe3\xbb\xfa\xb5\xc8\xbc\xb6 \xbf\xbc\xca\xd4'		#输出内容

f = open("D://b.txt", "r")
for line in f: 
	print(line) 				#按行输出内容
f.close()
```

用完文件一定要给关掉，要不然会造成内存泄漏、占用资源啥的。当然也可以用`with open('abc.txt','a') as file1:`这样的句子来打开文件，程序调用结束后文件会自动关闭。

|         方法          |                             含义                             |
| :-------------------: | :----------------------------------------------------------: |
|    f.read(size=-1)    | 从文件中读入整个文件内容。参数可选，如果给出，读入 前size长度的字符串或字节流 |
| f.readline(size = -1) | 从文件中读入一行内容。参数可选，如果给出，读入该行 前size长度的字符串或字节流 |
| f.readlines(hint=-1)  | 从文件中读入所有行，以每行为元素形成一个**列表**。参数 可选，如果给出，读入hint行 |
|    f.seek(offset)     | 改变当前文件操作指针的位置，offset的值： 0：文件开头； 2: 文件结尾 |
|      f.write(s)       |                 向文件写入一个字符串或字节流                 |
|  f.writelines(lines)  |             将一个元素为字符串的**列表**写入文件             |

### 数据组织的维度

1、2、3、4这样叫一维数据

下表是二维数据：

|  1   |  2   |
| :--: | :--: |
| 小红 | 小明 |

高维数据：

```
"本书" : [
		"第1章" : "程序设计基本方法", 
		"第2章" : "Python语言基本语法元素", 
		]
```

那么这样的数据怎么存入文件呢？上面说的写入都是将列表中的元素原封不动的存入txt文件中，通过向元素中加入换行符等等对写入进行格式调整，其实我们也可以用其他方法。

其中用逗号分割的存储格式叫做`csv`格式（Comma-Separated Values，即逗号分隔值）

```
ls = ['北京', '上海', '天津', '重庆'] 
f = open("city.csv", "w") 
f.write(",".join(ls)+ "\n") 
f.close()
```

写入效果为`北京,上海,天津,重庆`这样的好处是在读写数据时调整格式而不改变给出数据的样式。

对一维数据进行处理首先需要从CSV格式文件读 入一维数据，并将其表示为列表对象。 

```
f = open("city.csv", "r")
#strip("\n")函数用于移除开头和结尾的换行符，split(",")用“，”分割数据
ls = f.read().strip('\n').split(",") 
f.close() 
print(ls)		#['北京', '上海', '天津', '重庆'] 
```

二维数据也挺好理解的，就是若干条一维数据存在一起，如下示例

```
ls = [ 
	['指标', '2014年', '2015年', '2016年'],
	['居民消费价格指数', '102', '101.4', '102'], 
	]
```

二维列表对象写入为CSV格式文件方法如下，采 用遍历循环和字符串的join()方法相结合。 因为`join()`函数对一维列表用的，直接上二维的话他无法识别到里面的内容，写出来的话可能不尽人意。读取是同样道理。

```
# ls代表二维列表，此处省略 
f = open("cpi.csv", "w") 
for row in ls:     
	f.write(",".join(row)+ "\n") 
f.close()
```

## 第八章  Python计算生态

### 考纲考点

 1、基本的Python内置函数		2、了解Python计算生态

计算思维的本质是抽象（Abstraction）和自动化（Automation）

 一个解决复杂问题行之有效的方法被称作自顶而下的设计方法，其基本思想是以一个总问题开始，试图把它表达为很多小问题组成的解决方案。再用同样的技术依次攻破每个小问题，最终问题变得非常小，以至于可以很容易解决。然后只需把所有的碎片组合起来，就可以得到一个程序。

整个过程可以概括为四个步骤： 步骤1：将算法表达为一系列小问题； 步骤2：为每个小问题设计接口；步骤3：通过将算法表达为接口关联的多个小问 题来细化算法；步骤4：为每个小问题重复上述过程。

执行中等规模程序的最好方法是从结构图最底层开始，而不是从顶部开始，然后逐步上升。自顶向下和自底向上贯穿程序设计和执行的整个过程。

## 第九章  Python标准库概览

### 考纲考点

标准库: turtle库(必选)	 random库(必选)		time库(可选）

### turtle库

turtle库就是一只笔，画画用的。导入库有三种方式：

```
import turtle 
turtle.circle(200）		#画圆
from turtle import * 
circle(200)				#画圆
import turtle as t 
t.circle(200)			#画圆
```

 turtle库包含100多个功能函数，主要包括窗体函 数、画笔状态函数、画笔运动函数等三类。

#### 窗体函数

`turtle.setup(width, height, startx, starty)` 

作用：设置主窗体的大小和位置

参数：

 width ：窗口宽度，如果值是整数，表示的像素值；如果值 是小数，表示窗口宽度与屏幕的比例； 

height: 窗口高度，如果值是整数，表示的像素值；如果 值是小数，表示窗口高度与屏幕的比例；

startx：窗口左侧与屏幕左侧的像素距离，如果值是None ，窗口位于屏幕水平中央；

starty：窗口顶部与屏幕顶部的像素距离，如果值是None ，窗口位于屏幕垂直中央；

#### 画笔状态函数

|      函数      |                   描述                    |
| :------------: | :---------------------------------------: |
|   pendown()    |                 放下画笔                  |
|    penup()     |       提起画笔，与pendown()配对使用       |
| pensize(width) |       设置画笔线条的粗细为指定大小        |
|   pencolor()   |              设置画笔的颜色               |
|  begin_fill()  |          填充图形前，调用该方法           |
|   end_fill()   |               填充图形结束                |
|   filling()    | 返回填充的状态，True为填充，False为未填充 |
|    clear()     |   清空当前窗口，但不改变当前画笔的位置    |
|    reset()     |  清空当前窗口，并重置位置等状态为默认值   |
|  screensize()  |             设置画布的长和宽              |
|  hideturtle()  |           隐藏画笔的turtle形状            |
|  showturtle()  |           显示画笔的turtle形状            |
|  isvisible()   |        如果turtle可见，则返回True         |

#### 画笔运动函数

|             函数             |                描述                |
| :--------------------------: | :--------------------------------: |
|    forward()   /    fd()     |      沿着当前方向前进指定距离      |
|          backward()          |    沿着当前相反方向后退指定距离    |
|         right(angle)         |         向右旋转angle角度          |
|         left(angle)          |         向左旋转angle角度          |
|          goto(x,y)           |      移动到绝对坐标（x,y）处       |
|           setx( )            |      将当前x轴移动到指定位置       |
|           sety( )            |      将当前y轴移动到指定位置       |
| setheading(angle)  /  seth() | 设置当前朝向为angle角度，整数角度  |
|            home()            |   设置当前画笔位置为原点，朝向东   |
|       circle(radius,e)       | 绘制一个指定半径r和角度e的圆或弧形 |
|         dot(r,color)         | 绘制一个指定半径r和颜色color的圆点 |
|            undo()            |        撤销画笔最后一步动作        |
|           speed()            | 设置画笔的绘制速度，参数为0-10之间 |

### random库

使用random库主要目的是生成随机数 ，其中 最基本的函数是random.random()，它生成 一个[0.0, 1.0)之间的随机小数，其他随 机函数都是基于这个函数扩展而来。

|              函数              |                            描述                            |
| :----------------------------: | :--------------------------------------------------------: |
|          seed(a=None)          |           初始化随机数种子，默认值为当前系统时间           |
|            random()            |              生成一个[0.0, 1.0)之间的随机小数              |
|         randint(a, b)          |                  生成一个[a,b]之间的整数                   |
|         getrandbits(k)         |                生成一个k比特长度的随机整数                 |
| randrange(start, stop[, step]) |      生成一个[start, stop)之间以step为步数的随机整数       |
|         uniform(a, b)          |                生成一个[a, b]之间的随机小数                |
|          choice(seq)           | 从序列类型(例如：列表)中随机返回一个元素，从列表随机选一个 |
|          shuffle(seq)          |         将序列类型中元素随机排列，返回打乱后的序列         |
|         sample(pop, k)         |         从pop类型中随机选取k个元素，以列表类型返回         |

```
from random import *
seed(10) 
random() 
0.5714025946899135 
random() 
0.4288890546751146 
seed(10)   #再次设置相同的种子，则后续产生的随机数相同，所以说计算机得到的随机数都不是真正意义上的随机
random() 
0.5714025946899135
random() 
0.4288890546751146
```

### time库

time库的功能主要分为3个方面：时间处理、 时间格式化和计时

 时间处理主要包括4个函数：`time.time()`、 `time.gmtime()`、`time.localtime()` 、`time.ctime()`

时间格式化主要包括3个函数：`time.mktime()`、 `time.strftime()`、`time.strptime()`

计时主要包括3个函数：`time.sleep()` 、 `time.monotonic()`、`time.perf_counter()`

```
from time import *
now=time()											#获取当前时间戳
print(now)
print(gmtime(now))									#获取当前时间戳对应 的struct_time对象
print(localtime(now))								#获取当前时间戳对 应的本地时间的struct_time对象
print(ctime(now))									#获取当前时间戳对应的 易读字符串表示
print(mktime(localtime(now)))							#将struct_time对象t转换为时间戳
print(strftime("%Y-%m-%d %H:%M:%S",localtime(now)))		#利用一个 格式字符串，对时间格式进行表达。
timeString='2019-01-26 12:55:20'
print(strptime(timeString,"%Y-%m-%d %H:%M:%S"))			#提取字符串中时间来生成strut_time对象

#输出结果：
1563460629.0969484
time.struct_time(tm_year=2019, tm_mon=7, tm_mday=18, tm_hour=14, tm_min=37, tm_sec=9, tm_wday=3, tm_yday=199, tm_isdst=0)
time.struct_time(tm_year=2019, tm_mon=7, tm_mday=18, tm_hour=22, tm_min=37, tm_sec=9, tm_wday=3, tm_yday=199, tm_isdst=0)
Thu Jul 18 22:37:09 2019
1563460629.0

time.struct_time(tm_year=2019, tm_mon=1, tm_mday=26, tm_hour=12, tm_min=55, tm_sec=20, tm_wday=5, tm_yday=26, tm_isdst=-1)
```

time库与程序计时非常重要噢，这里可以自行写一个较多次数的循环，比如一个10000次的循环，然后每100次输出以下当前时间来了解。

## 第十章 第三方库概览

### 考纲考点

第三方库的获取和安装、脚本程序转变为可执行程序的第三方库:PyInstaller库(必选)、jieba库(必选)、wordcloud库（可选）

### Python第三方库的获取和安装

三个方法：pip工具安装、自定义安装、文件安装

#### pip工具安装

最常用且最高效的Python第三方库安装方式是 采用pip工具安装。pip是Python官方提供并维 护的在线第三方库安装工具。 可以安装超 过90%以上的第三方库。在Mac OS X和Linux等操 作系统中，pip工具几乎可以安装任何Python第三方库， 在Windows操作系统中，有一些第三方库仍然需要用其他方式尝试安装。

安装方式，打开cmd命令行就可以，然后`pip install <拟安装库名>`

另外输入命令`pip -h`回车还可以查看pip常用的子命令， pip支持安装（install）、下载（download）、 卸载（uninstall）、列表（list）、查看（list）、 查找（search）等一系列安装和维护子命令。

#### 自定义安装

自定义安装指按照第三方库提供的步骤和方式安装。以科学计算 用的numpy为例，开发者维护的官方主页是： [http://www.numpy.org/](http://www.numpy.org/) 浏览该网页找到下载链接，如下： [http://www.scipy.org/scipylib/download.html](http://www.scipy.org/scipylib/download.html) 进而根据指示步骤安装。

#### 文件安装

为了解决这类第三方库安装问题，美国加州大学尔湾分 校提供了一个页面，帮助Python用户获得Windows可直 接安装的第三方库文件，链接地址如下： [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)

这里以scipy为例说明，首先在上述页面中找到scipy库 对应的内容。选择其中的.whl文件下载，这里选择适用 于Python 3.5版本解释器和32位系统的对应文件：scipy0.17.1-cp35-cp35m-win32.whl，下载该文件到 D:\pycodes目录。 然后，采用`pip install D:\pycodes\scipy-0.17.1-cp35-cp35m-win32.whl` 命令安装该文件。

优先使用pip安装，没网的时候提前下载`.whl`文件，然后使用文件安装，就ok

### 第三方库

#### PyInstaller库

 PyInstaller是一个十分有用的Python第三方库，它能够 在Windows、Linux、Mac OS X等操作系统下将Python 源文件打包，变成直接可运行的可执行文件。 通过对源文件打包，Python程序可以在没有安装Python 的环境中运行，也可以作为一个独立文件方便传递和管理。可以试试用pip安装命令自己安装试试啊。

然后使用`PyInstaller <Python源程序文件名>`进行打包，执行完毕后，源文件所在目录将生成dist和build 两个文件夹。最终的打包程序在dist内部与源文 件同名的目录中。`PyInstaller -F <Python源程序文件名>`将Python文件生成一个独立可执行的文件。执行后在dist目录中出现了SnowView.exe文件， 没有任何依赖库，即可执行。

|            参数            |                功能                |
| :------------------------: | :--------------------------------: |
|         -h, --help         |              查看帮助              |
|          --clean           |      清理打包过程中的临时文件      |
|        -D, --onedir        |        默认值，生成dist目录        |
|       -F, --onefile        | 在dist文件夹中只生成独立的打包文件 |
| -i < 图 标 文 件 名 .ico > | 指定打包程序使用的图标（icon）文件 |

#### jieba库

由于中文文本中的单词不是通过空格或者标点符号分割，中文及类似语言存在一个重要的“分词”问题。  jieba（“结巴”）是Python中一个重要的第三 方中文分词函数库。`pip install jieba`

 jieba库支持三种分词模式：**精确模式**，将句子最 精确地切开，适合文本分析；**全模式**，把句子中所有可以成词的词语都扫描出来，速度非常快，但是不能解决歧义；**搜索引擎模式**，在精确模式基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。

对中文分词来说，jieba库只需要一行代码即可。

```
import jieba 
ls=jieba.lcut("全国计算机等级考试") 
print(ls)
#然后就：
['全国', '计算机', '等级', '考试']
```

 jieba.lcut(s)是最常用的中文分词函数，用于精准 模式，即将字符串分割成等量的中文词组，返回结果是列表类型。

 jieba.lcut(s, cut_all = True)用于全模式，即将字 符串的所有分词可能均列出来，返回结果是列表类型，冗余性最大。

 jieba.lcut_for_search(s)返回搜索引擎模式，该 模式首先执行精确模式，然后再对其中长词进一步切分获得最终结果。

 jieba.add_word()函数，顾名思义，用来向jieba 词库增加新的单词。这样再将中文分词的时候就会按照新添加的词库来分。

#### wordcloud库

 wordcloud库是专门用于根据文本生成词云的 Python第三方库，十分常用且有趣。pip按照噢。

 wordcloud库的使用十分简单，以一个字符串为 例。其中，产生词云只需要一行语句

```
form wordcloud import WordClout
txt="Github is funny,I like github"
wordcloud=WordCloud().generate(txt)
words = jieba.lcut(txt)        # 精确分词 
newtxt = ' '.join(words)       # 空格拼接 
wordcloud123=WordCloud(font_path="msyh.ttc").generate(newtxt) 
wordcloud.to_file('testcloud.png') 	#也可以存为图片
```

在生成词云时，wordcloud默认会以空格或标点 为分隔符对目标文本进行分词处理。对于中文文本，分词处理需要由用户来完成。一般步骤是先将文本分词处理，然后以空格拼接，再调用 wordcloud库函数。

还有wordcloud库与可视化词云的使用，网不行了，没法实战演示

## 第十一章 Python第三方库纵览

### 考点考纲

更广泛的Python计算生态，只要求了解第三方库的名称，不限于以下领域: 网络爬虫、数据分析、文本处理、数据可视化、用户图形界面、机器学习、Web开发、游戏开发等

**以下内容了解一下就行了**

### 网络爬虫方向

网络爬虫是自动进行HTTP访问并捕获HTML页 面的程序。Python语言提供了多个具备网络爬 虫功能的第三方库。这里，仅介绍2个常用的 Python网络爬虫库：requests和scrapy。

 requests库是一个简洁且简单的处理HTTP请求的第三方 库，它的最大优点是程序编写过程更接近正常URL访问 过程。这个库建立在Python语言的urllib3库基础上。 request库支持非常丰富的链接访问功能。 

scrapy是Python开发的一个快速的、高层次的Web获取 框架。不同于简单的网络爬虫功能，scrapy框架本身包 含了成熟网络爬虫系统所应该具有的部分共用功能，用途广泛，可以应用于专业爬虫系统的构建、数 据挖掘、网络监控和自动化测试等领域。 

### 数据分析方向

数据分析是Python的一个优势方向，具有大批高质量的 第三方库。这里仅介绍3个最常用的生态库：numpy、 scipy和pandas

numpy是Python的一种开源数值计算扩展第三方库，用 于处理数据类型相同的多维数组（ndarray），简称“数 组”。 这个库可用来存储和处理大型矩阵，比Python语言提供 的列表结构要高效的多。numpy提供了许多高级的数值 编程工具，如：矩阵运算、矢量处理、N维数据变换等。numpy内部是C语言编写，对外采用Python语言进行封 装，因此，在进行数据运算时，基于numpy的Python程 序可以达到接近C语言的处理速度。numpy也成为 Python数据分析方向各其他库的基础依赖库，已经成为 了科学计算事实上的“标准库”。 

 scipy是一款方便、易于使用、专为科学和工程设计的 Python工具包。在numpy库的基础上增加了众多的数学、 科学以及工程计算中常用的库函数。它包括统计、优化、整合、线性代数、傅里叶变换、信号分析、图像处理、常微分方程求解等众多模块。

pandas是基于numpy扩展的一个重要第三方库，它是为 了解决数据分析任务而创建的。Pandas提供了一批标准 的数据模型和大量快速便捷处理数据的函数和方法，提供了高效地操作大型数据集所需的工具。 pandas提供两种最基本的数据类型：Series和DataFrame，分别代表一维数组和二维数组类型。 

### 文本处理方向

Python语言非常适合处理文本，因此，在这个 方向也形成了大量有价值的第三方库。这里介绍 4个最常用的生态库：pdfminer、openpyxl、 python-docx、beautifulsoup4。

pdfminer是一个可以从PDF文档中提取各类信 息的第三方库。与其他PDF相关的工具不同，它能够完全获取并分析 PDF 的文本数据，Pdfminer能够获取PDF中文本的准确位置、字体、行数等信息，能够将PDF文件转换为HTML及文本格式。pdfminer包含两个重要工具：pdf2txt.py和dumppdf.py。pdf2txt.py能够从PDF文件中提取所有文本内容。 dumppdf.py能够把PDF文件内容变成XML格式，并进一步提取其中的图片。 

openpyxl是一个处理Microsoft Excel文档的Python第三方库，它支持读写Excel的xls、xlsx、xlsm、xltx、xltm 等格式文件，并进一步能处理Excel文件中excel工作表、 表单和数据单元。 

python-docx是一个处理Microsoft Word文档的Python第三方库，它支持读取、查询以及修改doc、docx等格 式文件，并能够对Word常见样式进行编程设置，包括： 字符样式、段落样式、表格样式等，进一步可以使用这
个库实现添加和修改文本、图像、样式和文档等功能。 

beautifulsoup4库，也称为BeautifulSoup库或 bs4库，用于解析和处理HTML和XML。需要注意，它不是BeautifulSoup库。它的最大优点是能根据HTML和XML语法建立解析树，进而高效解析其中的内容，并且可以将数据从HTML和XML文件中解析出来，它能够提供一种符合习惯的方法去遍历搜索和修改 解析树，将专业的Web页面格式解析部分封装成函数，提供了若干有用且便捷的处理函数。 

### 数据可视化方向

数据可视化指根据数据特点将其展示为易于理解 图形的过程。Python语言在数据可视化方面具 有较强的优势。这里介绍3个最常用的生态库： matplotlib、TVTK、mayavi。

 matplotlib是提供数据绘图功能的第三方库，主 要进行二维图表数据展示，广泛用于科学计算的 数据可视化。使用这个库可以利用Python程序 绘制超过100种数据可视化效果。 

TVTK库在标准的VTK库之上用Traits库进行封装的 Python第三方库。视觉工具函数库（VTK）是一个开源、 跨平台、支持平行处理的图形应用函数库，它是专业可 编程的三维可视化工具。TVTK在Python生态系统中被 等同于VTK。 

mayavi基于VTK开发，完全用Python编写，提供了一个 更为方便实用的可视化软件，可以简洁地嵌入到用户编 写的Python程序中，或者直接使用其面向脚本的API快 速绘制三维可视化图形。值得注意的是，mayavi也被称 为mayavi2。 mayavi库在Windows平台上暂时不能方便的使用pip命 令安装，建议使用文件安装，请下载mayavi对应版本文 件，然后在本地安装。

### 用户图形界面方向

Python标准库内置了一个GUI库——tkinter，这 个库基于Tck/Tk开发，然而，这个库十分陈旧， 提供的开发控件也很有限，编写出来的GUI风格 与现代程序GUI风格相差甚远，从用户体验角度 说，tkinter库并不成熟。 这里介绍3个高质量的用户图形界面Python生态 库：pyqt5、wxpython、pygtk。

pyqt5是Qt5应用框架的Python第三方库，它有超过620个类和近6000个函数和方法。它是 Python中最为成熟的商业级GUI第三方库。这个库是Python语言当前最好的GUI第三方库，它可以在Windows、Linux和Mac OS X等操作系统上跨平台使用。pyqt5采用“信号-槽”机制将事件和对应的处理 程序进行绑定。pyqt5窗体有很多内置信号，也可以自定义信号。 

wxPython是Python语言的一套优秀的GUI图形库，它 是跨平台GUI库wxWidgets的Python封装，可以使 Python程序员能够轻松地创建健壮可靠、功能强大的图 形用户界面的程序。 

pygtk是基于GTK+的Python语言封装，它提供了各式的 可视元素和功能，能够轻松创建具有图形用户界面的程 序。pygtk具有跨平台性,利用它编写的代码能够不加修 改地稳定运行在各操作系统中，如Windows、MacOS、 Linux等。 

### 机器学习方向

机器学习是人工智能领域的一个重要分支， Python语言也是机器学习和人工智能的重要基 础语言。这里介绍3个高质量的机器学习框架： Scikit-learn、TensorFlow、Theano。

 Scikit-learn是一个简单且高效的数据挖掘和数据分析工 具，它基于NumPy、SciPy和matplotlib构建。Scikitlearn的基本功能主要包括6个部分：分类，回归，聚类， 数据降维，模型选择和数据预处理。Scikit-learn也被称 为sklearn。 

TensorFlow是谷歌公司基于DistBelief进行研发的第二代 人工智能学习系统，也是用来支撑著名的AlphaGo系统 的后台框架。Tensor（张量）指N维数组，Flow（流） 指基于数据流图的计算，TensorFlow描述张量从流图的 一端流动到另一端的计算过程。 

 Theano为执行深度学习中大规模神经网络算法的运算而 设计，擅长处理多维数组。Theano开发始于2007，可以 理解它是一个运算数学表达式的编译器，并可以高效运 行在GPU或CPU上。Theano是一个偏向底层开发的库， 更像一个研究平台而非单纯的深度学习库。 

### Web开发方向

Web开发是Python语言流行的一个重要方向， 主要用于服务器后端开发。根据Python Web开 发框架的复杂程度，这里依次介绍3个Python第 三方生态库：Django、Pyramid、Flask。

 Django是Python生态中最流行的开源Web应用框架。 Django采用模型、模板和视图的编写模式，称为MTV模 式。Django中提供了开发网站经常用到的模块，Django 的开发理念是DRY(Don't Repeat Yourself)，用于鼓励快 速开发，进而减少程序员可以建立一个高性能Web应用 所花费的时间和精力，形成一种一站式解决方案。 

Pyramid是一个通用、开源的Python Web应用程序开发 框架。它主要的目的是让Python开发者更简单的创建 Web应用，相比Django，Pyramid是一个相对小巧、快 速、灵活的开源Python Web框架。Pyramid仍然面向较 大规模的Web应用，但它更关注灵活性，开发者可以灵 活选择所使用的数据库、模板风格、URL结构等内容。 

Flask是轻量级Web应用框架，相比Django和Pyramid， 它也被称为微框架。使用Flask开发Web应用十分方便， 甚至几行代码即可建立一个小型网站。Flask核心十分简 单，并不直接包含诸如数据库访问等的抽象访问层，而是通过扩展模块形式来支持。 

### 游戏开发方向

游戏开发是一个有趣的方向，在游戏逻辑和功能 实现层面，Python已经成为重要的支撑性语言。 这里介绍3个Python第三方生态库：Pygame、 Panda3D、cocos2d。 

 Pygame是在SDL库基础上进行封装的、面向游 戏开发入门的Python第三方库，除了制作游戏 外，还用于制作多媒体应用程序。其中，SDL （Simple DirectMedia Layer）是开源、跨平台 的多媒体开发库，通过OpenGL和Direct3D底层 函数提供对音频、键盘、鼠标和图形硬件的简洁
访问。Pygame是一个游戏开发框架，提供了大量与游 戏相关的底层逻辑和功能支持，非常适合作为入门库理解并实践游戏开发。 

Panda3D是一个开源、跨平台的3D渲染和游戏开发库, 简答说，它是一个3D游戏引擎，由迪士尼和卡耐基梅隆 大学娱乐技术中心共同进行开发。Panda3D支持Python 和C++两种语言，但对Python支持更全面。 Panda3D支持很多当代先进游戏引擎所支持的特性：法 线贴图、光泽贴图、HDR、卡通渲染和线框渲染等。 

cocos2d是一个构建2D游戏和图形界面交互式应用的框 架，它包括C++、JavaScript、Swift、Python等多个版 本。cocos2d基于OpenGL进行图形渲染，能够利用GPU 进行加速。cocos2d引擎采用树形结构来管理游戏对象， 一个游戏划分为不同场景，一个场景又分为不同层，每个层处理并响应用户事件。 
